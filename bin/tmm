#!/usr/bin/env ruby

require 'optparse'
require 'json'
require 'open3'
require 'tempfile'
require 'digest'

# Tmux Monorepo Manager - Enhanced session manager for monorepo projects
#
# This tool provides an intelligent tmux session manager that automatically
# discovers projects in monorepos and provides a fast, interactive interface
# for switching between sessions and projects.
#
# Features:
# - Automatic monorepo discovery
# - Fast caching system for performance
# - Interactive fzf-based session selector
# - Multiple data source support (tmux, sesh configs, zoxide, discovered projects)
# - Project-aware session creation with startup commands
class TmuxMonorepoManager
  SCRIPT_DIR = File.dirname(__FILE__)
  SESH_DISCOVER_SCRIPT = File.join(SCRIPT_DIR, 'sesh_monorepo_discover')
  CACHE_TTL_SECONDS = 300 # 5 minutes

  # ANSI color codes for terminal output
  COLORS = {
    red: "\033[0;31m",
    green: "\033[0;32m",
    yellow: "\033[1;33m",
    blue: "\033[0;34m",
    reset: "\033[0m"
  }.freeze

  # Monorepo detection patterns
  MONOREPO_INDICATORS = %w[
    microservices core lib libraries components packages apps services
    infra infrastructure tools scripts
  ].freeze

  # Icon constants
  FOLDER_ICON = 'Û±â≠'
  PROJECT_ICON = 'üöÄ'
  HOME_ICON = 'üè†'

  def initialize
    @monorepo_root = ENV['MONOREPO_ROOT'] || Dir.pwd
    @verbose = false
    @known_monorepos = find_known_monorepos
    @cached_projects = nil
    @session_data = nil
    check_dependencies
  end

  #============================================================================
  # DEPENDENCY MANAGEMENT
  #============================================================================

  def check_dependencies
    missing_deps = []

    %w[sesh fzf-tmux tmux].each do |cmd|
      missing_deps << cmd unless command_exists?(cmd)
    end

    unless File.executable?(SESH_DISCOVER_SCRIPT)
      missing_deps << 'sesh_monorepo_discover'
    end

    error "Missing dependencies: #{missing_deps.join(', ')}" if missing_deps.any?
  end

  def command_exists?(command)
    system("which #{command} > /dev/null 2>&1")
  end

  #============================================================================
  # OUTPUT AND LOGGING
  #============================================================================

  def error(message)
    puts colorize(message, :red)
    exit 1
  end

  def info(message)
    puts colorize(message, :blue)
  end

  def success(message)
    puts colorize(message, :green)
  end

  def warning(message)
    puts colorize(message, :yellow)
  end

  def colorize(text, color)
    "#{COLORS[color]}#{text}#{COLORS[:reset]}"
  end

  #============================================================================
  # MONOREPO DISCOVERY
  #============================================================================

  # Discovers all known monorepos in the environment
  def find_known_monorepos
    known_repos = []

    # Check PROJECTS directory for monorepos
    known_repos.concat(find_monorepos_in_projects_dir)

    # Include explicitly set MONOREPO_ROOT
    if ENV['MONOREPO_ROOT'] && Dir.exist?(ENV['MONOREPO_ROOT'])
      known_repos << File.expand_path(ENV['MONOREPO_ROOT'])
    end

    # Check if current directory is inside a monorepo
    current_monorepo = find_parent_monorepo(Dir.pwd)
    known_repos << current_monorepo if current_monorepo

    known_repos.uniq
  end

  # Scans the PROJECTS directory for potential monorepos
  def find_monorepos_in_projects_dir
    projects_dir = ENV['PROJECTS']
    return [] unless projects_dir && Dir.exist?(projects_dir)

    projects_expanded = File.expand_path(projects_dir)
    Dir.entries(projects_expanded).map do |entry|
      next if entry.start_with?('.')

      repo_path = File.join(projects_expanded, entry)
      next unless Dir.exist?(repo_path)

      repo_path if looks_like_monorepo?(repo_path)
    end.compact
  end

  # Determines if a directory looks like a monorepo based on its contents
  def looks_like_monorepo?(dir_path)
    Dir.entries(dir_path).any? { |entry| MONOREPO_INDICATORS.include?(entry.downcase) }
  rescue Errno::EACCES, Errno::ENOENT
    false
  end

  # Walks up the directory tree to find a parent monorepo
  def find_parent_monorepo(start_path)
    current_path = File.expand_path(start_path)

    while current_path != '/'
      return current_path if looks_like_monorepo?(current_path)
      current_path = File.dirname(current_path)
    end

    nil
  end

  #============================================================================
  # SESSION DATA RETRIEVAL
  #============================================================================

  # Gets existing tmux sessions from sesh
  def get_sesh_sessions
    output, status = Open3.capture2('sesh list -t 2>/dev/null')
    return [] unless status.success?

    output.lines
          .map(&:strip)
          .reject { |line| line.start_with?('zoxide:') }
          .reject(&:empty?)
  end

  # Gets all monorepo projects with caching and deduplication
  def get_monorepo_projects(root_dir = @monorepo_root)
    @cached_projects ||= discover_all_monorepo_projects

    deduplicate_projects(@cached_projects, root_dir)
  end

  # Fast method for getting projects from a single monorepo (used for direct connections)
  def get_single_monorepo_projects(monorepo_path)
    cached_projects = get_cached_monorepo_projects(monorepo_path)
    return cached_projects if cached_projects

    discover_and_cache_monorepo_projects(monorepo_path)
  end

  #============================================================================
  # PROJECT DISCOVERY AND CACHING
  #============================================================================

  # Discovers projects from all known monorepos
  def discover_all_monorepo_projects
    all_projects = []

    @known_monorepos.each do |monorepo_path|
      next unless Dir.exist?(monorepo_path)

      cached_projects = get_cached_monorepo_projects(monorepo_path)
      if cached_projects
        all_projects.concat(cached_projects)
      else
        projects = discover_and_cache_monorepo_projects(monorepo_path)
        all_projects.concat(projects)
      end
    end

    all_projects
  end

  # Discovers projects for a single monorepo and caches the results
  def discover_and_cache_monorepo_projects(monorepo_path)
    begin
      output, status = Open3.capture2(SESH_DISCOVER_SCRIPT, monorepo_path)
      return [] unless status.success?

      projects = parse_discovery_output(output, monorepo_path)
      cache_monorepo_projects(monorepo_path, projects)
      projects
    rescue => e
      [] # Silently ignore errors for individual monorepos
    end
  end

  # Parses the output from the discovery script
  def parse_discovery_output(output, monorepo_path)
    output.lines.map do |line|
      parts = line.strip.split('|')
      next unless parts.length >= 2

      name, path = parts[0], parts[1]
      icon = parts[2] || PROJECT_ICON
      next unless name && path

      { name: name, path: path, icon: icon, monorepo: monorepo_path }
    end.compact
  end

  # Deduplicates projects, preferring those from the specified root_dir
  def deduplicate_projects(projects, root_dir)
    root_dir_expanded = File.expand_path(root_dir)
    unique_projects = {}

    projects.each do |project|
      existing = unique_projects[project[:name]]
      if existing.nil? || project[:monorepo] == root_dir_expanded
        unique_projects[project[:name]] = project
      end
    end

    unique_projects.values
  end

  #============================================================================
  # CACHING SYSTEM
  #============================================================================

  # Retrieves cached projects for a monorepo if valid
  def get_cached_monorepo_projects(monorepo_path)
    cache_file = cache_file_path(monorepo_path)
    return nil unless File.exist?(cache_file)

    cache_age = Time.now.to_i - File.mtime(cache_file).to_i
    return nil if cache_age > CACHE_TTL_SECONDS

    begin
      data = JSON.parse(File.read(cache_file))
      data.map { |p| { name: p['name'], path: p['path'], icon: p['icon'], monorepo: monorepo_path } }
    rescue
      nil
    end
  end

  # Caches projects for a monorepo
  def cache_monorepo_projects(monorepo_path, projects)
    cache_file = cache_file_path(monorepo_path)

    begin
      data = projects.map { |p| { name: p[:name], path: p[:path], icon: p[:icon] } }
      File.write(cache_file, JSON.generate(data))
    rescue
      # Ignore cache write errors
    end
  end

  # Generates cache file path for a monorepo
  def cache_file_path(monorepo_path)
    File.join(Dir.tmpdir, "tmm_cache_#{Digest::MD5.hexdigest(monorepo_path)}")
  end

  #============================================================================
  # SESSION MANAGEMENT
  #============================================================================

  # Generates the complete session list for display
  def generate_session_list(root_dir = @monorepo_root)
    @session_data = {}
    all_sessions = []

    add_existing_sessions(all_sessions)
    add_discovered_projects(all_sessions, root_dir)

    format_session_entries(all_sessions)
  end

  def add_existing_sessions(all_sessions)
    get_sesh_sessions.each do |line|
      next if line.empty?

      session_name = line.strip
      session_data = { name: session_name, path: '', type: 'existing' }

      @session_data[session_name] = session_data
      all_sessions << session_data
    end
  end

  def add_discovered_projects(all_sessions, root_dir)
    monorepo_projects = get_monorepo_projects(root_dir)
    existing_names = @session_data.keys

    monorepo_projects.each do |project|
      next if existing_names.include?(project[:name])

      session_data = {
        name: project[:name],
        path: project[:path],
        type: 'project',
        icon: project[:icon],
        monorepo: project[:monorepo]
      }

      @session_data[project[:name]] = session_data
      all_sessions << session_data
    end
  end

  def format_session_entries(all_sessions)
    all_sessions.map do |session|
      icon = session[:icon] || default_icon_for_type(session[:type])
      "#{icon} #{session[:name]}"
    end
  end

  def default_icon_for_type(type)
    case type
    when 'existing' then FOLDER_ICON
    when 'project' then PROJECT_ICON
    else 'Óö≠'
    end
  end

  #============================================================================
  # SESSION CONNECTION
  #============================================================================

  # Connects to a session by name and path
  def connect_to_session(session_name, session_path, session_type)
    info "Connecting to session: #{session_name}" if @verbose

    case session_type
    when 'existing'
      system('sesh', 'connect', session_name)
    when 'project'
      create_project_session(session_name, session_path)
      system('sesh', 'connect', session_name)
    else
      system('sesh', 'connect', session_name)
    end
  end

  # Creates a new tmux session for a project
  def create_project_session(session_name, session_path)
    return if session_exists?(session_name)

    # Show temporary config in verbose mode
    show_temp_config_if_verbose(session_name, session_path)

    # Create and configure the session
    system('tmux', 'new-session', '-d', '-s', session_name, '-c', session_path)
    system('tmux', 'send-keys', '-t', session_name, 'sesh_current_up', 'Enter')
  end

  # Checks if a tmux session already exists
  def session_exists?(session_name)
    existing_sessions, status = Open3.capture2('tmux', 'list-sessions', '-F', '#{session_name}')
    status.success? && existing_sessions.lines.any? { |line| line.strip == session_name }
  end

  # Shows temporary sesh config in verbose mode
  def show_temp_config_if_verbose(session_name, session_path)
    return unless @verbose

    temp_config = create_temp_sesh_config(session_name, session_path)
    begin
      info "Created temporary config: #{temp_config.path}"
      info "Config contents:"
      info File.read(temp_config.path)
    ensure
      temp_config.unlink
    end
  end

  # Creates a temporary sesh configuration file
  def create_temp_sesh_config(session_name, session_path)
    temp_config = Tempfile.new(['sesh_temp_', '.toml'])
    temp_config.write(<<~TOML)
      [[session]]
      name = "#{session_name}"
      path = "#{session_path}"
      startup_command = "sesh_current_up"
    TOML
    temp_config.close
    temp_config
  end

  #============================================================================
  # INTERACTIVE INTERFACE
  #============================================================================

  # Main interactive session selector using fzf
  def interactive_selector(root_dir = @monorepo_root)
    temp_file = create_initial_session_file

    begin
      monorepo_display = create_monorepo_display_text
      fzf_command = build_fzf_command(monorepo_display, root_dir)

      selected_line = execute_fzf_selection(fzf_command, temp_file)
      handle_session_selection(selected_line, root_dir) if selected_line
    ensure
      temp_file.unlink if temp_file
    end
  end

  # Creates initial session file with existing sessions for fast display
  def create_initial_session_file
    temp_file = Tempfile.new('tmm_sessions')
    sesh_sessions = get_sesh_sessions
    initial_entries = sesh_sessions.map { |line| "#{FOLDER_ICON} #{line.strip}" }

    temp_file.write(initial_entries.join("\n"))
    temp_file.close
    temp_file
  end

  # Creates display text for monorepo information
  def create_monorepo_display_text
    case @known_monorepos.length
    when 0
      "Current Directory"
    when 1
      monorepo_path = @known_monorepos.first
      "#{HOME_ICON} #{File.basename(monorepo_path)} (#{truncate_path_for_display(monorepo_path, 40)})"
    else
      monorepo_names = @known_monorepos.map { |path| File.basename(path) }.join(", ")
      "#{HOME_ICON} Multiple Monorepos: #{monorepo_names}"
    end
  end

  # Builds the fzf command with all options and keybindings
  def build_fzf_command(monorepo_display, root_dir)
    full_command = "#{__FILE__} -r '#{root_dir}' list 2>/dev/null | grep -E '^  [#{PROJECT_ICON}#{FOLDER_ICON}#{HOME_ICON}]' | sed 's/^  //'"

    [
      'fzf-tmux', '-p', '80%,70%',
      '--border-label', " tmm - #{monorepo_display} ",
      '--prompt', '‚ö° ',
      '--header', '  C-a all | C-t tmux | C-g configs | C-x zoxide | C-r projects',
      '--bind', 'tab:down,btab:up',
      '--bind', "ctrl-a:change-prompt(‚ö° )+reload(#{full_command})",
      '--bind', "ctrl-t:change-prompt(ü™ü )+reload(sesh list -t)",
      '--bind', "ctrl-g:change-prompt(‚öôÔ∏è )+reload(sesh list -c)",
      '--bind', "ctrl-x:change-prompt(#{FOLDER_ICON} )+reload(sesh list -z)",
      '--bind', "ctrl-r:change-prompt(#{PROJECT_ICON} )+reload(#{create_projects_only_command(root_dir)})",
      '--preview', 'echo "üìç Selected: {}"',
      '--preview-window', 'right:50%:wrap',
      '--ansi',
      '--tiebreak=begin,length',
      '--algo=v2'
    ]
  end

  # Executes fzf selection and returns the selected line
  def execute_fzf_selection(fzf_command, temp_file)
    selected_line, status = Open3.capture2(*fzf_command, stdin_data: File.read(temp_file.path))

    unless status.success?
      info "No session selected" if @verbose
      return nil
    end

    selected_line.strip!
    selected_line.empty? ? nil : selected_line
  end

  # Handles the user's session selection
  def handle_session_selection(selected_line, root_dir)
    session_name = selected_line.gsub(/^[#{PROJECT_ICON}#{FOLDER_ICON}#{HOME_ICON}] /, '').strip.split(' ').first

    session_info = @session_data[session_name] if @session_data
    session_info ||= find_session_info(session_name, root_dir)

    if session_info
      connect_to_session(session_info[:name], session_info[:path], session_info[:type])
    else
      error "Session information not found for: #{session_name}"
    end
  end

  #============================================================================
  # UTILITY METHODS
  #============================================================================

  # Creates command for projects-only display
  def create_projects_only_command(root_dir)
    "#{SESH_DISCOVER_SCRIPT} #{root_dir} 2>/dev/null | while IFS='|' read -r name path icon; do echo \"${icon:-#{PROJECT_ICON}} $name\"; done"
  end

  # Truncates path for display with smart $PROJECTS substitution
  def truncate_path_for_display(path, max_length)
    # Handle $PROJECTS substitution
    projects_path = ENV['PROJECTS']
    if projects_path && !projects_path.empty?
      projects_expanded = File.expand_path(projects_path)
      if path.start_with?(projects_expanded)
        path = path.sub(projects_expanded, '$PROJECTS')
        return path if path.length <= max_length

        # If still too long, truncate within $PROJECTS
        parts = path.split('/')
        return parts.length > 3 ? '$PROJECTS/.../' + parts[-2..-1].join('/') : path
      end
    end

    return path if path.length <= max_length

    # Handle home directory truncation
    home_path = File.expand_path("~")
    if path.start_with?(home_path)
      relative_path = path.sub(home_path, "~")
      return relative_path if relative_path.length <= max_length

      parts = relative_path.split('/')
      return parts.length > 3 ? "~/.../" + parts[-2..-1].join('/') : relative_path
    end

    # Generic path truncation
    parts = path.split('/')
    parts.length > 3 ? ".../" + parts[-2..-1].join('/') : path
  end

  # Finds session information by name
  def find_session_info(session_name, root_dir)
    # Check existing sessions first
    if get_sesh_sessions.include?(session_name)
      return { name: session_name, path: '', type: 'existing' }
    end

    # Check discovered projects
    project = get_monorepo_projects(root_dir).find { |p| p[:name] == session_name }
    return { name: project[:name], path: project[:path], type: 'project' } if project

    nil
  end

  #============================================================================
  # COMMAND IMPLEMENTATIONS
  #============================================================================

  # Connects to a session by name with fast discovery
  def connect_by_name(session_name, root_dir = @monorepo_root)
    # Check existing sessions first
    existing_session = get_sesh_sessions.find { |line| line.split(' ')[0] == session_name }
    if existing_session
      connect_to_session(session_name, '', 'existing')
      return
    end

    # Fast discovery: Check each known monorepo individually
    @known_monorepos.each do |monorepo_path|
      project = find_project_in_monorepo(session_name, monorepo_path)
      if project
        connect_to_session(session_name, project[:path], 'project')
        return
      end
    end

    # Also check specified root_dir if not in known monorepos
    unless @known_monorepos.include?(File.expand_path(root_dir))
      project = find_project_in_monorepo(session_name, root_dir)
      if project
        connect_to_session(session_name, project[:path], 'project')
        return
      end
    end

    error "Session not found: #{session_name}"
  end

  # Finds a specific project in a monorepo
  def find_project_in_monorepo(session_name, monorepo_path)
    projects = get_single_monorepo_projects(monorepo_path)
    projects.find { |p| p[:name] == session_name }
  end

  # Lists all sessions and projects
  def list_sessions(root_dir = @monorepo_root, format = 'table')
    case format
    when 'json'
      output_json_list(root_dir)
    else
      output_table_list(root_dir)
    end
  end

  # Outputs session list in JSON format
  def output_json_list(root_dir)
    existing_sessions = get_sesh_sessions.map do |line|
      parts = line.split(' ', 2)
      { name: parts[0], path: parts[1]&.strip || '' }
    end

    discovered_projects = get_monorepo_projects(root_dir)

    result = {
      existing_sessions: existing_sessions,
      discovered_projects: discovered_projects
    }

    puts JSON.pretty_generate(result)
  end

  # Outputs session list in table format
  def output_table_list(root_dir)
    display_monorepo_header
    puts ""

    puts colorize("Existing Sessions:", :blue)
    get_sesh_sessions.each do |line|
      puts "  #{FOLDER_ICON} #{line.strip}" unless line.empty?
    end

    puts ""
    puts colorize("Discovered Projects:", :blue)
    get_monorepo_projects(root_dir).each do |project|
      icon = project[:icon] || PROJECT_ICON
      monorepo_name = File.basename(project[:monorepo] || root_dir)
      puts "  #{icon} #{project[:name]} (#{monorepo_name})"
    end
  end

  # Displays monorepo header information
  def display_monorepo_header
    case @known_monorepos.length
    when 0
      puts colorize("#{HOME_ICON} Directory: #{format_path_with_projects(@monorepo_root)}", :blue)
    when 1
      display_root = format_path_with_projects(@known_monorepos.first)
      puts colorize("#{HOME_ICON} Monorepo: #{display_root}", :blue)
    else
      monorepo_names = @known_monorepos.map { |path| File.basename(path) }.join(", ")
      puts colorize("#{HOME_ICON} Monorepos: #{monorepo_names}", :blue)
    end
  end

  # Formats path with $PROJECTS substitution
  def format_path_with_projects(path)
    projects_path = ENV['PROJECTS']
    return path unless projects_path && !projects_path.empty?

    projects_expanded = File.expand_path(projects_path)
    path.start_with?(projects_expanded) ? path.sub(projects_expanded, '$PROJECTS') : path
  end

  # Discovers and outputs projects in simple format
  def discover_projects(root_dir = @monorepo_root)
    get_monorepo_projects(root_dir).each do |project|
      puts "#{project[:name]}|#{project[:path]}"
    end
  end

  #============================================================================
  # HELP AND MAIN EXECUTION
  #============================================================================

  # Shows help information
  def show_help
    puts <<~HELP
      Usage: #{$0} [OPTIONS] [COMMAND]

      Tmux Monorepo Manager - Enhanced session manager for monorepo projects

      COMMANDS:
          (no command)    Interactive session selector (default)
          list            List all sessions and projects
          connect NAME    Connect to specific session by name
          discover        Discover projects in monorepo
          help            Show this help message

      OPTIONS:
          -r, --root DIR      Set monorepo root directory (default: $PWD)
          -f, --format FORMAT Output format for list: table, json (default: table)
          -v, --verbose       Show detailed connection and selection messages
          -h, --help          Show this help message

      ENVIRONMENT VARIABLES:
          MONOREPO_ROOT       Default monorepo root directory
          PROJECTS            Directory to scan for monorepos

      EXAMPLES:
          #{$0}                           # Interactive session selector
          #{$0} list                      # List all sessions and projects
          #{$0} connect web-partner       # Connect to specific session
          #{$0} -r /path/to/monorepo      # Use different monorepo root
          #{$0} list -f json              # List in JSON format

      INTEGRATION:
          Add to your shell aliases:
              alias tmm='tmm'
              alias tml='tmm list'
    HELP
  end

  # Main execution method
  def run(args)
    options = parse_command_line_options(args)

    @monorepo_root = options[:root_dir]
    @verbose = options[:verbose] || false

    execute_command(options)
  end

  private

  # Parses command line options
  def parse_command_line_options(args)
    options = {
      command: nil,
      root_dir: @monorepo_root,
      format: 'table',
      session_name: nil,
      verbose: false
    }

    parser = create_option_parser(options)

    begin
      parser.parse!(args)
    rescue OptionParser::InvalidOption => e
      error "Unknown option: #{e.message}"
    end

    parse_command_arguments(args, options)
    options[:command] ||= 'interactive'

    options
  end

  # Creates the option parser
  def create_option_parser(options)
    OptionParser.new do |opts|
      opts.on('-h', '--help', 'Show help') { show_help; exit 0 }
      opts.on('-r', '--root DIR', 'Set monorepo root directory') { |root| options[:root_dir] = root }
      opts.on('-f', '--format FORMAT', 'Output format (table, json)') { |format| options[:format] = format }
      opts.on('-v', '--verbose', 'Show detailed messages') { options[:verbose] = true }
    end
  end

  # Parses command arguments
  def parse_command_arguments(args, options)
    return unless args.any?

    case args[0]
    when 'list', 'discover', 'help'
      options[:command] = args[0]
    when 'connect'
      if args[1]
        options[:command] = 'connect'
        options[:session_name] = args[1]
      else
        error "Session name required for connect command"
      end
    else
      options[:command] = args[0]
    end
  end

  # Executes the specified command
  def execute_command(options)
    case options[:command]
    when 'interactive'
      interactive_selector(@monorepo_root)
    when 'list'
      list_sessions(@monorepo_root, options[:format])
    when 'connect'
      connect_by_name(options[:session_name], @monorepo_root)
    when 'discover'
      discover_projects(@monorepo_root)
    when 'help'
      show_help
    else
      error "Unknown command: #{options[:command]}"
    end
  end
end

# Run if executed directly
if __FILE__ == $0
  manager = TmuxMonorepoManager.new
  manager.run(ARGV)
end
